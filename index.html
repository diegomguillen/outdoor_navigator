<script>
        // --- INICIO CÓDIGO ACTUALIZADO ---
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').catch(err => console.log(err));
        }

        let map;
        let routeLayer, userMarker; 
        let routePoints = []; 
        let wakeLock = null;
        let watchId = null;
        let isAutoCentering = true;
        let lastUserPosition = null;

        // Variables de capas
        let osmLayer, satelliteLayer;
        let currentBaseLayer = 'osm';

        // Elementos DOM
        const statusPanel = document.getElementById('statusPanel');
        const dirIndicator = document.getElementById('directionIndicator');
        const gpsText = document.getElementById('gpsAccuracy');
        const btnRecenter = document.getElementById('btnRecenter');
        const btnLayer = document.getElementById('btnLayer');
        const wakeStatus = document.getElementById('wakeLockStatus');

        // ICONO FLECHA SVG
        const arrowIconHtml = `
            <svg viewBox="0 0 24 24" width="40" height="40" style="filter: drop-shadow(0px 0px 3px rgba(0,0,0,0.8));">
                <path d="M12 2 L2 22 L12 18 L22 22 Z" fill="#FF0000" stroke="white" stroke-width="2"/>
            </svg>`;

        const navigationIcon = L.divIcon({
            className: 'nav-arrow-icon',
            html: `<div id="userArrow" style="transform-origin: center; transition: transform 0.3s ease;">${arrowIconHtml}</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20] // Centro del icono
        });

        function initMap() {
            osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19, attribution: '© OpenStreetMap'
            });

            satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles © Esri'
            });

            map = L.map('map', {
                center: [37.9838, -1.1280], 
                zoom: 13,
                layers: [osmLayer], 
                zoomControl: false 
            });

            map.on('dragstart', () => disableAutoCenter());
            map.on('zoomstart', () => disableAutoCenter());

            loadRouteFromStorage();
        }

        // --- BOTONES ---
        btnLayer.addEventListener('click', () => {
            if (currentBaseLayer === 'osm') {
                map.removeLayer(osmLayer);
                map.addLayer(satelliteLayer);
                currentBaseLayer = 'sat';
                if(routeLayer) routeLayer.setStyle({ color: '#00FFFF' });
            } else {
                map.removeLayer(satelliteLayer);
                map.addLayer(osmLayer);
                currentBaseLayer = 'osm';
                if(routeLayer) routeLayer.setStyle({ color: '#0000FF' });
            }
        });

        document.getElementById('btnLoad').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                processGPX(content);
                localStorage.setItem('saved_route_gpx', content);
            };
            reader.readAsText(file);
        }, false);

        btnRecenter.addEventListener('click', () => {
            isAutoCentering = true;
            btnRecenter.style.display = 'none';
            if (userMarker) {
                map.flyTo(userMarker.getLatLng(), 18);
            }
        });

        function loadRouteFromStorage() {
            const savedGPX = localStorage.getItem('saved_route_gpx');
            if (savedGPX) processGPX(savedGPX);
        }

        function processGPX(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "text/xml");
            const trkpts = xmlDoc.getElementsByTagName("trkpt");
            routePoints = [];
            
            for (let i = 0; i < trkpts.length; i++) {
                routePoints.push([
                    parseFloat(trkpts[i].getAttribute("lat")),
                    parseFloat(trkpts[i].getAttribute("lon"))
                ]);
            }
            if (routePoints.length > 0) drawRoute();
        }

        function drawRoute() {
            if (routeLayer) map.removeLayer(routeLayer);
            const routeColor = (currentBaseLayer === 'sat') ? '#00FFFF' : '#0000FF';

            routeLayer = L.polyline(routePoints, {
                color: routeColor, weight: 6, opacity: 0.8, lineJoin: 'round'
            }).addTo(map);

            map.fitBounds(routeLayer.getBounds(), { padding: [20, 20] });
            statusPanel.style.display = 'block';
            startNavigation();
        }

        function startNavigation() {
            requestWakeLock();
            if (!navigator.geolocation) return;
            if (watchId) navigator.geolocation.clearWatch(watchId);

            watchId = navigator.geolocation.watchPosition(
                updateUserPosition,
                (err) => { gpsText.innerText = "Error GPS"; },
                { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
            );
        }

        function updateUserPosition(position) {
            const { latitude: lat, longitude: lon, accuracy, heading } = position.coords;
            gpsText.innerText = `Precisión: ±${Math.round(accuracy)}m`;

            // 1. Crear o mover marcador
            if (!userMarker) {
                // Usamos el icono de flecha
                userMarker = L.marker([lat, lon], { icon: navigationIcon }).addTo(map);
            } else {
                userMarker.setLatLng([lat, lon]);
            }

            // 2. Rotar la flecha según el rumbo (Heading)
            // El heading viene en grados (0 = Norte, 90 = Este, etc.)
            // Solo es válido si nos estamos moviendo
            const arrowElement = document.getElementById('userArrow');
            if (arrowElement && heading !== null && !isNaN(heading)) {
                arrowElement.style.transform = `rotate(${heading}deg)`;
            }

            // 3. Auto-centrado
            if (isAutoCentering) {
                map.panTo([lat, lon]);
            }
            calculateDirectionVector(lat, lon);
        }

        function calculateDirectionVector(lat, lon) {
            if (routePoints.length < 2) return;
            
            let minDist = Infinity;
            let idx = 0;
            for (let i = 0; i < routePoints.length; i++) {
                const d = (lat - routePoints[i][0])**2 + (lon - routePoints[i][1])**2;
                if (d < minDist) { minDist = d; idx = i; }
            }

            let nextIdx = (idx + 1) % routePoints.length;
            const vr_lat = routePoints[nextIdx][0] - routePoints[idx][0];
            const vr_lon = routePoints[nextIdx][1] - routePoints[idx][1];

            if (!lastUserPosition) {
                lastUserPosition = { lat, lon };
                return;
            }
            
            const dMoved = Math.sqrt((lat - lastUserPosition.lat)**2 + (lon - lastUserPosition.lon)**2);
            if (dMoved < 0.00002) return; 

            const vu_lat = lat - lastUserPosition.lat;
            const vu_lon = lon - lastUserPosition.lon;
            lastUserPosition = { lat, lon };

            const dot = (vu_lat * vr_lat) + (vu_lon * vr_lon);

            if (dot > 0) {
                dirIndicator.innerHTML = "ADELANTE &#8593;";
                dirIndicator.className = "status-value direction-ok";
            } else {
                dirIndicator.innerHTML = "&#8595; REVES";
                dirIndicator.className = "status-value direction-wrong";
            }
        }

        function disableAutoCenter() {
            if (isAutoCentering) {
                isAutoCentering = false;
                btnRecenter.style.display = 'flex';
            }
        }

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeStatus.innerText = "Pantalla: ACTIVA";
                    wakeStatus.style.color = "#00FF00";
                    wakeLock.addEventListener('release', () => {
                        wakeStatus.innerText = "Pantalla: Normal";
                        wakeStatus.style.color = "#FFF";
                    });
                } catch (e) { console.log(e); }
            }
        }
        
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock();
        });

        initMap();
    </script>